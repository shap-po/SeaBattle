# 32. SeaBattle-2

## Автор

Шаповалов В'ячеслав Олександрович, 2 курс, комп'ютерна математика 2

## Завдання

Створити гру МОРСЬКИЙ БІЙ у наступній варіації.
Поле 10*10 (можна задати і інші розміри) заповнюється лише єдиним однопалубним кораблем. Постріли робляться одиничні та у якості відповіді повідомлюється відстань (манхеттенська, тобто L1) до корабля.
Після пострілу супротивника гравець повинен/може рухати корабель на сусідню позицію (N4 або N8 – за домовленістю) (але не може бути там, де вже був постріл супротивника).
Перемагає той, хто перший потопив корабель супротивника.
Гравці кожен час мають бачити всі результати та робити нотатки на власній копії карти (можна псевдографікою).
Розробіть варіанти гри двох супротивників на одному комп'ютері, гри з комп'ютером, що стріляє випадково (але не повторюючись) та гри з розумним комп'ютером, що має непогану стратегію гри.

Додатково: Клієнт-серверний варіант.
Реферативна частина містить опис програми, алгоритмів та стратегій гри.

## Сторонні бібліотеки

Програма написана на мові C++ з використанням бібліотеки FTXUI для реалізації графічного інтерфейсу користувача.

## Опис програми

### Початок гри

`main` - вхідна точка програми, викликає функцію `getGameOptions, яка, за допомогою графічного інтерфейсу, дозволяє користувачу вибрати налаштування гри.
Далі викликається фабричний метод `createGame`, який повертає відповідний об'єкт гри, який відповідає інтерфейсу `IGame`. Цей інтерфейс містить єдиний метод `start`, який починає гру.

### Налаштування гри

До налаштувань гри відносяться:
- Тип гри (Гравець проти гравця, Гравець проти комп'ютера)
- Розмір поля
- Мапа переміщень корабля (на які клітинки можна переміщати корабель після пострілу)
- Стратегія комп'ютера (Легка, Середня, Важка); доступно тільки в режимі Гравець проти комп'ютера

### Гра

Абстрактний клас `Game`, який імплементує інтерфейс `IGame`, містить в собі загальні методи для всіх видів гри, а саме:
- `start` - метод, який викликається для початку гри. Він послідовно викликає методи `prepare`, `gameLoop` та `end`.
- `prepare` - метод, який викликається перед початком гри. Він відповідає за запит гравців щодо розміщення кораблів на полі.
- `gameLoop` - метод, який викликається після `prepare` і відповідає за основний цикл гри. Він послідовно викликає метод `playerTurn` для кожного гравця, доки не буде досягнуто кінця гри.
- `playerTurn` - метод, який викликається під час ходу гравця. Він звертається до поточного гравця і запитує та валідує його хід. Після надання валідного ходу, він передає результати обом гравцям.
- `end` - метод, який викликається після закінчення гри. Він відповідає за оголошення результатів гри.

### Поле

Клас `Field` відповідає за представлення поля гри у вигляді сітки з клітин (`Cell`).

### Клітинка

Enum `Cell` відповідає за представлення клітинки поля гри. Він моє приймати наступні значення:
- `EMPTY` - пуста клітинка
- `SHIP` - клітинка з кораблем
- `MISS` - клітинка, в яку було здійснено постріл, але не було корабля
- `HIT` - клітинка, в якій влучили по кораблю

### Гравець

Абстрактний клас `Player` відповідає за представлення гравця. Від типу гравця залежать 2 параметри:
- `isComputer` - чи є гравець комп'ютером
- `isHost` - чи є гравець господарем, якщо гра має 2 господарів - це гра на одному комп'ютері
Він також містить в собі методи, які викликаються під час гри:
- `placeShip` - метод, який викликається під час підготовки гравця до гри. Він відповідає за запит гравця щодо розміщення кораблів на полі.
- `makeShot` - відповідає за запит гравця щодо пострілу.
- `makeMove` - відповідає за запит гравця щодо переміщення корабля.
- `setShotResult` - відповідає за передачу результатів ходу гравця.
- `setEnemyShotResult` - метод, який викликається після ходу опонента. Він відповідає за передачу результатів ходу опонента.
- `communicate` - метод для передачі повідомлень гравцям.

### Комп'ютер

Клас `ComputerPlayer` наслідується від `Player` і відповідає за представлення гравця-комп'ютера.
Стратегія комп'ютера визначається відповідно до налаштувань гри.

#### Легка стратегія

Комп'ютер робить все випадково, не використовуючи жодних тактик.

#### Середня стратегія

##### Підготовка

Комп'ютер розміщує корабель випадково, але не на краю поля.

##### Постріл

Комп'ютер намагається знайти корабель супротивника, стріляючи тільки в клітинки, на необхідній відстані від попереднього пострілу (з урахуванням можливості переміщення)
Наприклад, якщо попередній постріл був в клітинку e5, та відстань до корабля 2, то комп'ютер буде стріляти в клітинки b5, c4-6, d3-7, e2-8, f3-7, g4-6, h5.

```
  1 2 3 4 5 6 7 8 9 10
a ░░░░░░░░░░░░░░░░░░░░
b ░░░░░░░░  ░░░░░░░░░░
c ░░░░░░      ░░░░░░░░
d ░░░░          ░░░░░░
e ░░      XX      ░░░░
f ░░░░          ░░░░░░
g ░░░░░░      ░░░░░░░░
h ░░░░░░░░  ░░░░░░░░░░
i ░░░░░░░░░░░░░░░░░░░░
j ░░░░░░░░░░░░░░░░░░░░
```

##### Переміщення

Комп'ютер ходить випадково, але уникає країв поля.

#### Важка стратегія

##### Підготовка

Комп'ютер розміщує корабель ближче до центру поля.

##### Постріл

Комп'ютер обчислює всі можливі варіанти пострілів, шукаючи той, який зменшує кількість можливих клітинок для розміщення корабля супротивника найбільше.
Першим пострілом буде обрано клітину ближче до краю, бо кількість можливих розташувань ворожого корабля відносно пострілу виглядає ось так:

```
10|10|10|10|10|10|10|10|10|10
10|11|11|11|12|12|11|11|11|10
10|11|12|12|14|14|12|12|11|10
10|11|12|14|16|16|14|12|11|10
10|12|14|16|18|18|16|14|12|10
10|12|14|16|18|18|16|14|12|10
10|11|12|14|16|16|14|12|11|10
10|11|12|12|14|14|12|12|11|10
10|11|11|11|12|12|11|11|11|10
10|10|10|10|10|10|10|10|10|10

```
Приклад:

```
░░░░░░  ░░  ░░░░░░░░
░░░░  ░░░░░░  ░░░░░░
░░  ░░░░░░░░░░  ░░░░
  ░░░░░░░░░░░░░░  ░░
░░░░░░░░XX░░░░░░░░  
  ░░░░░░░░░░░░░░  ░░
░░  ░░░░░░░░░░  ░░░░
░░░░  ░░░░░░  ░░░░░░
░░░░░░  ░░  ░░░░░░░░
░░░░░░░░  ░░░░░░░░░░
```

##### Переміщення

Комп'ютер ходить випадково, але уникає країв поля та клітинок, в які вже стріляли.
